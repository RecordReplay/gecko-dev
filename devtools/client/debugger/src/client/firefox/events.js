/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

// @flow

import type {
  SourcePacket,
  PausedPacket,
  ThreadFront,
  Target,
  DebuggerClient,
} from "./types";

import Actions from "../../actions";

import { createPause, prepareSourcePayload, createFrame } from "./create";
import { clientCommands } from "./commands";
import sourceQueue from "../../utils/source-queue";
import { recordEvent } from "../../utils/telemetry";
import { prefs, features } from "../../utils/prefs";

const {
  WorkersListener,
  // $FlowIgnore
} = require("devtools/client/shared/workers-listener.js");

type Dependencies = {
  actions: typeof Actions,
  debuggerClient: DebuggerClient,
};

let actions: typeof Actions;
let isInterrupted: boolean;
let threadFrontListeners: WeakMap<ThreadFront, Array<Function>>;
let workersListener: Object;

function addThreadEventListeners(thread: ThreadFront) {
  const removeListeners = [];
  Object.keys(clientEvents).forEach(eventName => {
    // EventEmitter.on returns a function that removes the event listener.
    removeListeners.push(
      thread.on(eventName, clientEvents[eventName].bind(null, thread))
    );
  });
  threadFrontListeners.set(thread, removeListeners);
}

function removeThreadEventListeners(thread: ThreadFront) {
  const removeListeners = threadFrontListeners.get(thread) || [];
  for (const removeListener of removeListeners) {
    removeListener();
  }
}

function attachAllTargets(currentTarget: Target) {
  return prefs.fission && currentTarget.isParentProcess;
}

function setupEvents(dependencies: Dependencies) {
  const { debuggerClient } = dependencies;
  actions = dependencies.actions;
  sourceQueue.initialize(actions);

  debuggerClient.mainRoot.on("processListChanged", threadListChanged);

  workersListener = new WorkersListener(debuggerClient.mainRoot);

  threadFrontListeners = new WeakMap();
}

function setupEventsTopTarget(targetFront: Target) {
  targetFront.on("workerListChanged", threadListChanged);
  addThreadEventListeners(targetFront.threadFront);

  if (features.windowlessServiceWorkers || attachAllTargets(targetFront)) {
    workersListener.addListener(threadListChanged);
  }
}

function removeEventsTopTarget(targetFront: Target) {
  targetFront.off("workerListChanged", threadListChanged);
  removeThreadEventListeners(targetFront.threadFront);
  workersListener.removeListener();
}

async function paused(threadFront: ThreadFront, packet: PausedPacket) {
  ChromeUtils.recordReplayLog("ThreadFront.paused");

  // When reloading we might get pauses from threads before they have been
  // added to the store. Ensure the pause won't be processed until we've
  // finished adding the thread.
  await actions.ensureHasThread(threadFront.actor);

  // If paused by an explicit interrupt, which are generated by the
  // slow script dialog and internal events such as setting
  // breakpoints, ignore the event.
  const { why } = packet;
  if (why.type === "interrupted" && !packet.why.onNext) {
    isInterrupted = true;
    return;
  }

  if (why.type == "alreadyPaused") {
    return;
  }

  if (packet.frame) {
    // When reloading we might receive a pause event before the
    // top frame's source has arrived.
    await actions.ensureSourceActor(
      threadFront.actorID,
      packet.frame.where.actor
    );
  }

  const pause = createPause(threadFront.actor, packet);

  actions.paused(pause);
  recordEvent("pause", { reason: why.type });
}

function resumed(threadFront: ThreadFront) {
  // NOTE: the client suppresses resumed events while interrupted
  // to prevent unintentional behavior.
  // see [client docs](../README.md#interrupted) for more information.
  if (isInterrupted) {
    isInterrupted = false;
    return;
  }

  actions.resumed(threadFront.actorID);
}

function newSource(threadFront: ThreadFront, { source }: SourcePacket) {
  sourceQueue.queue({
    type: "generated",
    data: prepareSourcePayload(threadFront, source),
  });
}

function threadListChanged() {
  actions.updateThreads();
}

function replayFramePositions(
  threadFront: ThreadFront,
  { positions, unexecutedLocations, frame, thread }: Object
) {
  actions.setFramePositions(positions, unexecutedLocations, frame, thread);
}

// Copied from execution-point-utils.js, which has trouble being
// require()'ed here for some reason.

function positionToString(pos) {
  return `${pos.kind}:${pos.script}:${pos.offset}:${pos.frameIndex}`;
}

function pointToString(point) {
  if (point.position) {
    return `${point.checkpoint}:${point.progress}:${positionToString(
      point.position
    )}`;
  }
  return `${point.checkpoint}:${point.progress}`;
}

const gStepTargets = new Map();
const gPausePackets = new Map();
const gCachedForms = new Map();

// Destructively modify a piece of JSON by replacing references to cached forms
// with the actual form, reconstructing a complete form with the contents
// expected by other parts of the client.
function replaceCachedFormReferences(json) {
  if (!json || typeof json != "object") {
    return;
  }

  if (Array.isArray(json)) {
    for (let i = 0; i < json.length; i++) {
      const v = json[i];
      if (v && v.cached) {
        json[i] = replaceCachedForm(v);
      } else {
        replaceCachedFormReferences(v);
      }
    }
  } else {
    for (const [key, v] of Object.entries(json)) {
      if (v && v.cached) {
        json[key] = replaceCachedForm(v);
      } else {
        replaceCachedFormReferences(v);
      }
    }
  }
}

function addCachedForm(form) {
  if (!form.actor) {
    throw new Error("Expected cached form actor");
  }

  replaceCachedFormReferences(form);
  gCachedForms.set(form.actor, form);
}

function replaceCachedForm(form) {
  if (!form.cached) {
    throw new Error("Expected cached form reference");
  }

  const cached = gCachedForms.get(form.cached);
  if (!cached) {
    throw new Error("Unknown cached form");
  }

  return cached;
}

function replayPreloadedData(threadFront, entry) {
  switch (entry.data.kind) {
    case "InvalidateStepTargets":
      gStepTargets.clear();
      break;
    case "StepTargets": {
      const { point, stepOver, stepIn, stepOut, reverseStepOver } = entry.data;
      gStepTargets.set(pointToString(point), { stepOver, stepIn, stepOut, reverseStepOver });
      break;
    }
    case "PauseData": {
      const { point, environment, frames, cachedForms } = entry.data;
      cachedForms.forEach(addCachedForm);
      const thread = clientCommands.getMainThread();
      gPausePackets.set(pointToString(point), {
        frames: frames.map((frame, i) => createFrame(thread, replaceCachedForm(frame), i)),
        environment: replaceCachedForm(environment),
      });
      break;
    }
    default:
      throw new Error("Bad preloaded data kind");
  }
}

function canInstantStep(point, limit) {
  if (!point) {
    return null;
  }
  const entries = gStepTargets.get(pointToString(point));
  const target = entries && entries[limit];
  if (!target) {
    return null;
  }
  const info = gPausePackets.get(pointToString(target));
  if (info) {
    return { executionPoint: target, ...info };
  }
  return null;
}

const clientEvents = {
  paused,
  resumed,
  newSource,
  replayFramePositions,
  replayPreloadedData,
};

export {
  removeEventsTopTarget,
  setupEvents,
  setupEventsTopTarget,
  clientEvents,
  addThreadEventListeners,
  attachAllTargets,
  canInstantStep,
};
